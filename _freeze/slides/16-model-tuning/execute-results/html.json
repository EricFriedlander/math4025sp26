{
  "hash": "15289ae7c84d7c7fc2a514ddedd41151",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'MATH 427: Model Tuning'\nauthor: Eric Friedlander\nfooter: \"[ðŸ”— MAT 427 - Spring 2025 -  Schedule](https://mat427sp25.netlify.app/schedule)\"\nlogo: \"../images/logo.png\"\nformat: \n  revealjs:\n    theme: slides.scss\n    multiplex: false\n    transition: fade\n    slide-number: false\n    incremental: false \n    chalkboard: true\nexecute:\n  freeze: auto\n  echo: true\n  cache: true\nknitr:\n  opts_chunk: \n    R.options:      \n    width: 200\n---\n\n\n\n## Computational Set-Up\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(fivethirtyeight)\nlibrary(knitr)\ntidymodels_prefer()\n\nset.seed(427)\n```\n:::\n\n\n\n\n## Data: Candy {.smaller}\n\nThe data from this lab comes from the the article FiveThirtyEight [*The Ultimate Halloween Candy Power Ranking*](https://fivethirtyeight.com/features/the-ultimate-halloween-candy-power-ranking) by Walt Hickey. To collect data, Hickey and collaborators at FiveThirtyEight set up an experiment people could vote on a series of randomly generated candy matchups (e.g. Reese's vs. Skittles). Click [here](http://walthickey.com/2017/10/18/whats-the-best-halloween-candy/) to check out some of the match ups.\n\nThe data set contains 12 characteristics and win percentage from 85 candies in the experiment.\n\n## Data: Candy\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(candy_rankings)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 85\nColumns: 13\n$ competitorname   <chr> \"100 Grand\", \"3 Musketeers\", \"One dime\", \"One quarterâ€¦\n$ chocolate        <lgl> TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, Fâ€¦\n$ fruity           <lgl> FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSEâ€¦\n$ caramel          <lgl> TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE,â€¦\n$ peanutyalmondy   <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, â€¦\n$ nougat           <lgl> FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE,â€¦\n$ crispedricewafer <lgl> TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSEâ€¦\n$ hard             <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSâ€¦\n$ bar              <lgl> TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, Fâ€¦\n$ pluribus         <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUEâ€¦\n$ sugarpercent     <dbl> 0.732, 0.604, 0.011, 0.011, 0.906, 0.465, 0.604, 0.31â€¦\n$ pricepercent     <dbl> 0.860, 0.511, 0.116, 0.511, 0.511, 0.767, 0.767, 0.51â€¦\n$ winpercent       <dbl> 66.97173, 67.60294, 32.26109, 46.11650, 52.34146, 50.â€¦\n```\n\n\n:::\n:::\n\n\n\n## Data Cleaning\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncandy_rankings_clean <- candy_rankings |> \n  select(-competitorname) |> \n  mutate(sugarpercent = sugarpercent*100,\n         pricepercent = pricepercent*100)\n```\n:::\n\n\n\n## Data Splitting\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncandy_split <- initial_split(candy_rankings_clean, strata = winpercent)\ncandy_train <- training(candy_split)\ncandy_test <- testing(candy_split)\n```\n:::\n\n\n\n## Pre-processing\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_preproc <- recipe(winpercent ~ . , data = candy_train) |> \n  step_nzv(all_predictors()) |> \n  step_integer(all_logical_predictors()) |> \n  step_dummy(all_nominal_predictors())\n\nlm_preproc |> prep()\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}